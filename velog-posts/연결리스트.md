<h2 id="리스트란-">리스트란 ?</h2>
<ul>
<li>리스트에 새로운 항목 추가(삽입)</li>
<li>항목 삭제(삭제)</li>
<li>항목 찾기(탐색)</li>
</ul>
<h2 id="리스트-adt">리스트 ADT</h2>
<img alt="image" height="378" src="https://github.com/user-attachments/assets/f1b50f3d-09ed-4430-ac14-9361ea572d0c" width="912" />

<h2 id="리스트-구현-방법">리스트 구현 방법</h2>
<p><img alt="" src="https://velog.velcdn.com/images/kym11290306/post/1a10aadd-77ea-4a79-b48c-7af6bf131270/image.png" /></p>
<h2 id="배열로-구현된-리스트">배열로 구현된 리스트</h2>
<ul>
<li><p>배열을 이용하여 리스트를 구현하면 순차적인 메모리 공간이 할당된다 : 순차적 표현(Sequential representation)</p>
<img alt="image" height="121" src="https://github.com/user-attachments/assets/365efa13-b595-48e3-9d5c-f62abd82c3bf" width="341" />


</li>
</ul>
<h2 id="프로그램">프로그램</h2>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#define MAX_LIST_SIZE 100 // 리스트의 최대크기

typedef int element; // 항목의 정의

typedef struct {
    element array[MAX_LIST_SIZE]; // 배열 정의
    int size; // 현재 리스트에 저장된 항목들의 개수
} ArrayListType;
// 오류 처리 함수
void error(char* message)
{
    fprintf(stderr, &quot;%s\n&quot;, message);
    exit(1);
}
// 리스트 초기화 함수
void init(ArrayListType* L)
{
    L-&gt;size = 0;
}
// 리스트가 비어 있으면 1을 반환
// 그렇지 않으면 0을 반환
int is_empty(ArrayListType* L)
{
    return L-&gt;size == 0;
}
// 리스트가 가득 차 있으면 1을 반환
// 그렇지 많으면 1을 반환
int is_full(ArrayListType* L)
{
    return L-&gt;size == MAX_LIST_SIZE;
}
element get_entry(ArrayListType* L, int pos)
{
    if (pos &lt; 0 || pos &gt;= L-&gt;size)
        error(&quot;위치 오류&quot;);
    return L-&gt;array[pos];
}
// 리스트 출력
void print_list(ArrayListType* L)
{
    int i;
    for (i = 0; i &lt; L-&gt;size; i++)
        printf(&quot;%d-&gt;&quot;, L-&gt;array[i]);
    printf(&quot;\n&quot;);
}
void insert_last(ArrayListType* L, element item)
{
    if (L-&gt;size &gt;= MAX_LIST_SIZE) {
        error(&quot;리스트 오버플로우&quot;);
    }
    L-&gt;array[L-&gt;size++] = item;
}
void insert(ArrayListType* L, int pos, element item)
{
    if (!is_full(L) &amp;&amp; (pos &gt;= 0) &amp;&amp; (pos &lt;= L-&gt;size)) {
        for (int i = (L-&gt;size - 1); i &gt;= pos; i--)
            L-&gt;array[i + 1] = L-&gt;array[i];
        L-&gt;array[pos] = item;
        L-&gt;size++;
    }
}
element delete(ArrayListType* L, int pos)
{
    element item;

    if (pos &lt; 0 || pos &gt;= L-&gt;size)
        error(&quot;위치 오류&quot;);
    item = L-&gt;array[pos];
    for (int i = pos; i &lt; (L-&gt;size - 1); i++)
        L-&gt;array[i] = L-&gt;array[i + 1];
    L-&gt;size--;
    return item;
}
int main(void)
{
    // ArrayListType를 정적으로 생성하고 ArrayListType를     
    // 가리키는 포인터를 함수의 매개변수로 전달한다.
    ArrayListType list;

    init(&amp;list);
    insert(&amp;list, 0, 10);    print_list(&amp;list);    // 0번째 위치에 10 추가
    insert(&amp;list, 0, 20);    print_list(&amp;list);    // 0번째 위치에 20 추가
    insert(&amp;list, 0, 30);    print_list(&amp;list);    // 0번째 위치에 30 추가
    insert_last(&amp;list, 40);    print_list(&amp;list);    // 맨 끝에 40 추가
    delete(&amp;list, 0);        print_list(&amp;list);    // 0번째 항목 삭제
    return 0;
}</code></pre>
<img alt="image" height="247" src="https://github.com/user-attachments/assets/518eed98-6618-45b6-be9d-686fd88bb7cf" width="1112" />

<hr />
<h2 id="연결된-표현">연결된 표현</h2>
<ul>
<li>리스트의 항목들을 노드(node)라고 하는 곳에 분산하여 저장</li>
<li>노드는 데이터 필드 / 링크 필드로 구성<ul>
<li>데이터 필드 : 리스트의 원소, 즉 데이터 값 저장하는 곳</li>
<li>링크 필드 : 다른 노드의 주소값을 저장하는 곳(포인터)</li>
</ul>
</li>
</ul>
<h2 id="특징">특징</h2>
<ul>
<li>장점<ul>
<li>삽입, 삭제가 보다 용이하다.</li>
<li>연속된 메모리 공간이 필요 없다.</li>
<li>크기 제한이 없다.</li>
</ul>
</li>
<li>단점<ul>
<li>구현이 어렵다.</li>
<li>오류가 발생하기 쉽다.</li>
</ul>
</li>
</ul>
<h2 id="노드의-구조">노드의 구조</h2>
<ul>
<li>노드 = 데이터 필드 + 링크 필드</li>
</ul>
<img alt="image" height="116" src="https://github.com/user-attachments/assets/1afd8d7b-3eb3-437b-a3ab-d879f157fb34" width="528" />

<h2 id="연결-리스트의-종류">연결 리스트의 종류</h2>
<ul>
<li>단순 연결 리스트</li>
<li>원형 연결 리스트</li>
<li>이중 연결 리스트</li>
</ul>
<p><img alt="" src="https://velog.velcdn.com/images/mommers/post/e4ac8363-8fa7-4f06-92d1-236b53b77cbf/image.png" /></p>
<h2 id="단순-연결-리스트">단순 연결 리스트</h2>
<ul>
<li>하나의 링크 필드를 이용하여 연결</li>
<li>마지막 노드의 링크 값은 NULL</li>
</ul>
<img alt="image" height="143" src="https://github.com/user-attachments/assets/a6de0c48-2bcf-4aa5-bc9b-70d84d559c9d" width="876" />

<p>1) 노드의 정의</p>
<img alt="image" height="90" src="https://github.com/user-attachments/assets/e9c28ff4-b94e-425d-b7c8-ff6ccaef341e" width="251" />

<pre><code class="language-c">typedef int element;

typedef struct ListNode {     // 노드 타입을 구조체로 정의한다.
    element data;
    struct ListNode *link;
} ListNode;</code></pre>
<p>2) 리스트의 생성</p>
<img alt="image" height="107" src="https://github.com/user-attachments/assets/becbc23b-9f0a-4d77-99c3-b0882b7ed724" width="334" />

<pre><code class="language-c">ListNode *head = NULL;

head = (ListNode *)malloc(sizeof(ListNode)); 

head-&gt;data = 10;
head-&gt;link = NULL;</code></pre>
<p>3) 2번째 노드 생성</p>
<img alt="image" height="98" src="https://github.com/user-attachments/assets/5f8080f7-4c22-4a5d-bb0e-beb62039a891" width="664" />

<pre><code class="language-c">ListNode *p;
p = (ListNode *)malloc(sizeof(ListNode)); 
p-&gt;data = 20;
p-&gt;link = NULL; </code></pre>
<p>4) 노드의 연결 <code>head-&gt;link=p;</code></p>
<img alt="image" height="72" src="https://github.com/user-attachments/assets/0d959d6f-1d74-4dc9-b251-054c4c9e9c1c" width="473" />

<h2 id="단순-연결-리스트의-연산">단순 연결 리스트의 연산</h2>
<ul>
<li>insert_first(): 리스트의 시작 부분에 항목을 삽입하는 함수</li>
<li>insert(): 리스트의 중간 부분에 항목을 삽입하는 함수</li>
<li>delete_first(): 리스트의 첫 번째 항목을 삭제하는 함수</li>
<li>delete(): 리스트의 중간 항목을 삭제하는 함수</li>
<li>print_list(): 리스트를 방문하여 모든 항목을 출력하는 함수</li>
</ul>
<h2 id="단순-연결리스트-삽입-연산">단순 연결리스트 (삽입 연산)</h2>
<img alt="image" height="553" src="https://github.com/user-attachments/assets/615016ee-149b-4124-82a4-98ecdd15d6d8" width="476" />

<pre><code class="language-c">ListNode* insert_first(ListNode *head, int value)
{
    ListNode *p =
     (ListNode *)malloc(sizeof(ListNode));//(1)
    p-&gt;data = value;                    // (2)
    p-&gt;link = head;        //(3)
    head = p;    //(4)
    return head;
}
// 노드 pre 뒤에 새로운 노드 삽입
ListNode*  insert(ListNode *head, ListNode *pre, element value)
{
    ListNode *p = (ListNode *)malloc(sizeof(ListNode));    //(1)
    p-&gt;data = value;        //(2)
    p-&gt;link = pre-&gt;link;    //(3)    
    pre-&gt;link = p;        //(4)    
    return head;        //(5)    
}</code></pre>
<p><code>ListNode *p = (ListNode *) malloc(sizeof(ListNode));</code></p>
<ul>
<li><p>p는 주소 값을 저장하는 변수, 즉 포인터 변수이고,</p>
</li>
<li><p>⭐malloc() 함수의 반환하는 것도 주소값⭐</p>
</li>
<li><p>즉 p는 일반 변수(x 같은 값)이 아니라</p>
</li>
<li><p>노드가 저장된 메모리의 주소를 들고 있는 변수 =&gt; 포인터</p>
</li>
</ul>
<p><code>pre-&gt;link = p;</code> 이렇게 주소값이 연결되는게 맞다.</p>
<hr />
<p>⭐malloc이 하는 일⭐
<code>malloc(sizeof(ListNode))</code>
-&gt; 힙 영역에 <code>ListNode</code> 크기만큼 메모리를 할당
-&gt; 그 메모리의 시작 주소를 반환</p>
<p>즉, <code>malloc -&gt; &quot;여기에 노드를 만들어 뒀다, 시작 주소 = 0x1000&quot;</code></p>
<p>p는 무엇인가?</p>
<ul>
<li>선언을 보면 <code>ListNode *p;</code></li>
<li>p는 <code>ListNode</code>를 가리키는 포인터 변수.</li>
</ul>
<p>정리하면,</p>
<ul>
<li><code>p = 주소를 저장하는 변수</code></li>
<li>malloc 결과를 넣으면 p ----&gt; [새로 생성된 노드의 메모리 주소]</li>
</ul>
<h2 id="단순-연결리스트-삭제-연산">단순 연결리스트 (삭제 연산)</h2>
<img alt="image" height="354" src="https://github.com/user-attachments/assets/705da408-02a9-4d2d-8ea7-085c623ce2cb" width="537" />

<pre><code class="language-c">ListNode* delete_first(ListNode *head)
{
    ListNode *removed;
    if (head == NULL) return NULL;
    removed = head;    // (1)
    head = removed-&gt;link;    // (2)
    free(removed);        // (3)
    return head;        // (4)
}
// pre가 가리키는 노드의 다음 노드를 삭제한다. 
ListNode* delete(ListNode *head, ListNode *pre)
{
    ListNode *removed;
    removed = pre-&gt;link;
    pre-&gt;link = removed-&gt;link;        // (2)
    free(removed);            // (3)
    return head;            // (4)
}</code></pre>
<h2 id="방문-연산-코드">방문 연산 코드</h2>
<pre><code class="language-c">void print_list(ListNode *head)
{
    for (ListNode *p = head; p != NULL; p = p-&gt;link)
        printf(&quot;%d-&gt;&quot;, p-&gt;data);
    printf(&quot;NULL \n&quot;);
}</code></pre>
<p>31p까지 정리 //</p>
<p>과제 : 도서 제출 반납 프로그램
이중 연결 리스트를 이용해서 !!</p>