<ol>
<li>15장, 16장, 17장 과제 리뷰</li>
<li>전문가C -&gt; 전처리기 지시자</li>
<li></li>
</ol>
<hr />
<p>전처리 : preprocssing</p>
<ul>
<li>수행: 일련의 지시자(#)를 사용해 통제하고 영향을 줌</li>
<li>C 지시자: 헤더와 소스 파일에서 #으로 시작하는 코드(매크로, 조건부 컴파일)</li>
</ul>
<h3 id="111-매크로">1.1.1 매크로</h3>
<p>매크로의 활용 </p>
<ul>
<li>상수 정의 ⇒ const</li>
<li>C 함수를 작성하지 않고 함수로 사용하기 ⇒like function</li>
<li>루프 풀기</li>
<li>헤더 가드</li>
<li>코드 생성</li>
<li>조건부 컴파일</li>
<li><code>#define</code> 지시자를 이용해 정의 : 각 매크로는 이름과 파라미터, 값을 가짐</li>
<li><code>#undef</code> 지시자로 정의를 제거</li>
<li>매크로는 컴파일 이전 단계에서만 존재, 이론적으로는 컴파일러가 매크로에 관해 모른다는 뜻</li>
<li>하지만 현대의 C 컴파일러는 전처리 단계를 알고있다.</li>
<li>int 함수 쓰임?</li>
</ul>
<h3 id="112-조건부-컴파일">1.1.2 조건부 컴파일</h3>
<ul>
<li><code>#ifdef CONDITION</code> ~ <code>enfif</code></li>
<li>블럭 사이에 부분은 CONDITION이 어딘가에 정의되어 있지 않으면, 활성화 되지 않음.</li>
<li><code>gcc -DCONDITION -E main.c</code> 를 통해 컴파일하며 정의해줄 수 있음</li>
</ul>
<p>-</p>
<pre><code class="language-c">#inndef EXAMPLE_H
#define EXAMPLE_H

#endif</code></pre>
<hr />
<h3 id="12-포인터-변수">1.2 포인터 변수</h3>
<ul>
<li>포인터 : 메모리 주소를 저장하는 단순 변수</li>
<li>문서 상에는 <code>int* ptr = 0;</code> 으로 선언 시 꼭 초기화하라고 명시 되어있음.</li>
<li>널 포인터 선언, 참조 연산자 <code>&amp;</code> , 역참조 연산자 <code>*</code></li>
<li>NULL 매크로 사용 : 변수와 포인터를 더 쉽게 구분</li>
</ul>
<h3 id="122-포인터-변수의-산술-연산">1.2.2 포인터 변수의 산술 연산</h3>
<ul>
<li>산술연산 간격? -&gt; 포인터가 1씩 증감할때 움직이는 바이트의 숫자, C자료형을 기준으로 결정된다.</li>
<li><code>int형</code> 의 경우 4byte 씩, <code>char형</code> 의 경우 1byte 씩, 이동</li>
<li>포인터 산술 연산을 사용하지 않더라도, int형 및 char형 배열의 주소 크기도 동일하다.</li>
</ul>
<h3 id="123-제네릭-포인터-void">1.2.3 제네릭 포인터 (<code>void*</code>)</h3>
<ul>
<li><code>void*</code> 자료형의 포인터.</li>
<li><strong>역참조 불가능</strong> </li>
<li><code>void* vp=&amp;a</code> 가 있을때 역참조는 <code>*vp</code> (불가능)</li>
<li>받는건 어떤 자료형이든 무조건 받고, 사용할 때 문제가 된다.</li>
</ul>
<h3 id="124-포인터늬-크기">1.2.4 포인터늬 크기</h3>
<ul>
<li>아키텍처에 따라 포인터의 크기가 다름</li>
<li>대상 아키텍처에서 <code>sizeof 함수</code> 를 사용</li>
</ul>
<h3 id="125-허상-포인터---danggling">1.2.5 허상 포인터 - danggling</h3>
<ul>
<li>충돌 또는 세그멘테이션 오류 발생</li>
<li>ptr 포인터가 할당이 해제된 var의 메모리 영역을 가리킴(허상 포인터)</li>
</ul>
<hr />
<h3 id="13-함수">1.3 함수</h3>
<ul>
<li><p>이름, 입력 매개변수의 목록, 출력 결과의 목록을 가진 논리 상자</p>
</li>
<li><p>블로킹 함수 : 호출된 함수가 종료되어야만 반환값을 호출자 함수가 받을 수 있음.</p>
</li>
<li><p>논 블로킹 함수 : 콜백 메커니즘, 비동기 함수, 사건 기반 프로그래밍(EDP)</p>
</li>
<li><p>로직을 만들면 여러 곳에서 사용 가능</p>
</li>
<li><p>추상화 : 기존의 다른 로직으로부터 일부를 숨김(encapsulation ? )</p>
</li>
<li><p>스택 관리 : 스택 세그먼트 -&gt; 모든 지역 변수, 배열, 구조체가 할당되는 기본 메모리의 위치</p>
</li>
<li><p>스택 프레임 -&gt; 스택 세그먼트의 가장 위에 놓이고, 함수 로직이 실행된다. 호출이 끝나면 스택 프레임은 제거되며 직전 호출 함수로 계속 이어진다.</p>
</li>
</ul>
<hr />
<h3 id="14-함수-포인터">1.4 함수 포인터</h3>
<ul>
<li><p>함수의 주소를 저장하는 포인터, 간접적으로 호출 가능</p>
</li>
<li><p>이로 인해 모듈화가 가능해졌다.</p>
</li>
<li><p>함수 포인터 선언 : <code>int (*fptr)(int)</code> &lt;&lt; 해당함수의 반환형, 포인터변수, 해당함수의 매개변수의 형태 순서</p>
</li>
<li><p>C에는 <code>bool</code> 변수가 없었으나, <code>&lt;stdio.h&gt;</code> 가 업데이트 되면서 아래와 같이 사용</p>
<pre><code class="language-c">typedef int bool_t;
typedef bool_t(*less_than_func_t)(int,int);</code></pre>
</li>
</ul>
<hr />
<h3 id="15-구조체">1.5 구조체</h3>
<ul>
<li><p>원시 자료형(PDT) = 자료구조를 설계할 수 있고, 알고리즘을 작성할 수 있습니다.</p>
</li>
<li><p>하나 이상의 변수를 묶어서 사용할 수 있는 복잡 자료형</p>
</li>
<li><p>캡슐화(encapsulation) 가능 == 은닉화</p>
</li>
<li><p>왜 사용자 정의 자료형을 사용하는가?</p>
</li>
<li><p>서로 연관된 속성을 그룹으로 묶기 위해.</p>
</li>
<li><p>배열의 경우 같은 타입의 자료형만 가능한데, 구조체의 경우 여러 자료형을 묶어서 관리할 수 있음.</p>
</li>
<li><p>비즈니스 로직(도메인 지식) - 은행(고객, 잔고, 돈, 현금, 지불) 개념을 마주하고, 은행 로직을 개발하기 위해서는 개발자와 비즈니스 분석가는 협력하며 규칙, 로직, 용어집 등을 공유해야 한다.</p>
</li>
</ul>
<pre><code class="language-c">struct color_t{
  int red;
  int green;
  int blue;
};</code></pre>
<ul>
<li>위 구조와 같이 서로 관련이 있는 필드(red, green, blue)를 캡슐화를 할 수 있음</li>
<li>구조체 변수가 할당되는 순서에 따라 바이트 수가 달라질 수 있다.</li>
<li>구조체 포인터를 통해 사용하는 경우가 많다.</li>
<li>사용자 정의 자료형의 포인터는 원시 자료형의 포인터와 동일</li>
<li>구조체 변수 포인터가 구조체 변수의 첫 번째 필드의 주소를 가르킨다.</li>
</ul>
<p>헷갈리는 예제)</p>
<ul>
<li>p2와 p3의 주소값이 왜 같은가? -&gt; &amp;C를 받았으니까</li>
<li>p4, p5는 각각 double<em>, char</em>형 으로 형변환 해주었는데 왜 같은 주소값이 나오는가? -&gt; 같은 이유</li>
<li>그럼 저게 무슨 의미인가? -&gt; 어떤 자료형이든 상관없이 포인터 변수에 같은 C의 값을 저장 출력</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

typedef struct {
    int x;
    int y;
}point_t;

typedef struct {
    point_t center;
    int radius;
}circle_t;

int main(void)
{
    circle_t c;
    c.radius = 10;
    c.center.x = 100;
    c.center.y = 200;

    circle_t* p1 = &amp;c;
    point_t* p2 = (point_t*)&amp;c;
    int* p3 = (int*)&amp;c;
    double* p4 = (double*)&amp;c;
    char* p5 = (char*)&amp;c;

    printf(&quot;p1 = %p\n&quot;, (void*)p1);
    printf(&quot;p2 = %p\n&quot;, (void*)p2);
    printf(&quot;p3 = %d\n&quot;, *p3);
    printf(&quot;p4 = %p\n&quot;, (void*)p4);
    printf(&quot;p5 = %p\n&quot;, (void*)p5);
    return 0;
}</code></pre>
<hr />
<h3 id="21-표준-컴파일-파이프라인">2.1 표준 컴파일 파이프라인</h3>
<ul>
<li>전처리기 / 컴파일러 / 어셈블러 / 링커 : 네 가지 요소로 구성된 파이프 라인</li>
<li></li>
<li><strong>재배치 가능한 목적파일</strong>과 같은 어떤 중간 결과물은 소스파일 하나가 세 가지 요소(전처리기, 컴파일러, 어셈블러)만 성공적으로 통과하면 만들어짐</li>
<li>주소는 재배치 가능한 목적파일(오브젝트 코드) 를 가져와서 각 세그먼트별로 데이터를 뽑아와서 하나의 데이터 영역을 만들고, 코드 영역도 쭉 뽑아와서 코드 영역을 만든다.</li>
<li>데이터 영역, 코드 영역을 만들면 주소가 확정된다.</li>
</ul>
<h5 id="플랫폼">플랫폼</h5>
<ul>
<li>하드웨어에서 실행되는 운영체제의 결합</li>
<li>크로스 플랫폼은 (Intel용 이진파일, Arm용 이진파일 등등) 각 플랫폼마다 이진파일이 다르다.</li>
<li>이식 가능한 소프트웨어는 모든 플랫폼에서 같은 이진파일과 인스톨러를 사용<ul>
<li>gcc와 clang 같은 C컴파일러는 크로스 플랫폼 -&gt; 컴파일 해야만 실행 가능, 자바의 바이트 코드는 이식 가능 -&gt; 그냥 실행 가능</li>
<li>윈도우에서 컴파일한 파일 -&gt; Arm코어에서 실행 불가 .. 이런 느낌이 크로스 플랫폼, 하지만 자바의 바이트 코드는 둘 다 실행 o</li>
<li>C/C++ 코드가 이식 가능하다? -&gt; 따로 변경, 수정을 거치지 않아도 서로 다른 플랫폼에서 컴파일 할 수 있다는 말.</li>
<li>최종 목적 파일에 이식성이 있다는 의미가 아님</li>
</ul>
</li>
</ul>
<h3 id="211-프로젝트-빌드">2.1.1 프로젝트 빌드</h3>
<ul>
<li><p>헤더 파일 : .h (굳이 .h로 안해도 괜찮음)</p>
</li>
<li><p>소스 파일 : .c</p>
</li>
<li><p>헤더 파일은 주로 열거형, 매크로, 형식 정의, 함수의 선언, 전역변수, 구조체도 포함한다.</p>
</li>
<li><p>함수 선언(declare) -&gt; <code>double average(int*, int);</code> , 함수 정의(definition) -&gt; 중괄호 열고 함수 몸통 포함되어 있는 것</p>
</li>
<li><p>소스 파일 중 하나는 <code>main</code> 함수를 포함하는데, 프로그램의 진입점(entry-point)이다.</p>
</li>
<li><p>main 함수 없이는 프로그램의 실행 파일을 가질 수 없다.</p>
</li>
<li><p>컴파일러는 프로그램 시작점으로 <code>main()</code> 을 찾는다.</p>
</li>
<li><p>전방 선언 : 컴파일을 한번에 (함수를 정의하기 이전에 함수를 선언)</p>
</li>
<li><p>헤더 가드문 : 헤더 파일이 컴파일 될 때 두 번 또는 그 이상 포함되는 것을 방지한다.</p>
</li>
<li><p>규칙 1. 소스파일만 컴파일, 헤더 파일은 컴파일 하지 않는다.</p>
</li>
<li><p>규칙 2. 각 소스 파일을 따로따로 컴파일한다. 한번에 여러 파일을 컴파일 하지 않는다.</p>
</li>
</ul>
<h3 id="212-1단계--전처리">2.1.2) 1단계 : 전처리</h3>
<ul>
<li>컴파일 파이프라인의 첫 단계 : 전처리</li>
<li>컴파일이 시작되기 전에 전처리기가 헤더 파일의 내용을 모아 하나의 C코드 몸체로 만든다.</li>
<li>이후 전처리 지시자(<code>#include</code> , <code>#define</code> 등)는 이 단계에서 해결된다.</li>
<li>전처리된 코드는 변환단위, 혹은 컴파일 단위라고 한다.</li>
</ul>
<h3 id="213-2단계--컴파일">2.1.3) 2단계 : 컴파일</h3>
<p>assembly 코드 보기 편하게하는 vscode extension</p>
<p><img alt="" src="https://velog.velcdn.com/images/mommers/post/4884ef18-edc5-4bcf-b18f-951f74086065/image.png" /></p>
<p><img alt="" src="https://velog.velcdn.com/images/mommers/post/0778331f-d54e-4ca0-8382-bf88358f80d7/image.png" /></p>
<ul>
<li>offset 값이니까 맨 위에서부터 <code>-12(%rbp)</code> 등등</li>
<li>intel용으로 컴파일</li>
</ul>
<p><img alt="" src="https://velog.velcdn.com/images/mommers/post/b04177f7-4b8e-43ab-aa50-818d6454bec4/image.png" /></p>
<ul>
<li><p>x86용은 명령어 뒤에 인자가 2개가 아니라 3개, 4개 등 나올 수 있다.</p>
</li>
<li><p>한번에 두개를 비교해서 다른 레지스터에 저장, 한번에 3가지 4가지 등을 처리할 수 있는 복잡한 명령어가 많음</p>
</li>
<li><p>복잡한 명령어 셋을 가지고 있는 ? 라고함</p>
</li>
<li><p>여러개의 명령어 가지고 한번에 처리 할수있음(?)</p>
</li>
<li><p>x86은 복잡, 속도 빠름 / 전력 효율이 안 좋다는 단점</p>
</li>
<li><p>Arm은 구조가 단순, 간단. 핸드폰에 들어가는 코어는 대부분 Arm코어, 전력 효율이 좋은 편 / 저전력</p>
</li>
<li><p>대상 아키텍처 : 소스 파일이 컴파일되어 실행될 아키텍처</p>
</li>
<li><p>빌드 아키텍처 : 소스를 컴파일 할 때 사용하는 아키텍처</p>
</li>
<li><p>예를 들어 ARM 32비트 머신(빌드 아키텍처)에서 AMD 64비트 하드웨어(대상 아키텍처)를 위한 C소스를 컴파일 할 수 있다.</p>
</li>
</ul>
<h3 id="214-3단계--어셈블리">2.1.4) 3단계 : 어셈블리</h3>
<ul>
<li>입력값 : 어셈블리 코드 출력값 : 재배치 가능한 목적 파일(기계어 코드, 중간 목적 파일)</li>
<li>유닉스 계열 운영체제에서 어셈블러 도구는 <code>as</code> 이다.
<code>as ExtremeC_examples_chapter2_1.s -o ExtremeC_examples_chapter2_1.o</code></li>
<li>재배치 가능한 목적 파일은 .o 확장자</li>
<li>어셈블리 코드로 목적 파일을 생성 가능<pre><code class="language-c">gcc -c ExtremeC_examples_chapter2_1.c -o impl.o
gcc -c ExtremeC_examples_chapter2_1_main.c -o main.o</code></pre>
</li>
</ul>
<h3 id="215-4단계--링크">2.1.5) 4단계 : 링크</h3>
<ul>
<li>입력값 : 목적파일 결과값 : 실행파일</li>
</ul>
<pre><code>$ ld impl.o main.o
113쪽
$ gcc impl.o main.o
$ ./a.out</code></pre><hr />
<h3 id="31-abi">3.1 ABI</h3>
<ul>
<li><p>ABI, API는 수준(level)이 다르다.</p>
</li>
<li><p>API : 두 소프트웨어의 컴포넌트 간 호환성을 보장하여 기능적으로 계속 협력할 수 있도록 한다.</p>
</li>
<li><p>ABI : 두 프로그램이 명령어 수준에서 호환 가능하도록 두 프로그램 목적 파일을 함께 사용할 수 있게 한다.</p>
</li>
<li><p>ABI가 포함하는 내용</p>
<ul>
<li>대상 아키텍처의 명령어 집합</li>
<li>기존의 자료형과 크기 및 정렬 규칙</li>
<li>함수 호출 규칙</li>
<li>유닉스 계열 시스템에서 시스템 호출 방식 정의를 많이 따라감</li>
<li>사용된 목적 파일 형식: 재배치 가능한 실행 가능한, 공유 목적 파일에 관한 내용</li>
</ul>
</li>
</ul>
<h3 id="nm---심볼-테이블-확인">nm - 심볼 테이블 확인</h3>
<ul>
<li>바이너리의 심볼을 볼 때 사용하는 명령어</li>
<li><code>nm {binary_file_name}</code> 명령어 통해 사용</li>
</ul>
<p><img alt="" src="https://velog.velcdn.com/images/mommers/post/d81f7060-cfa1-4601-bbac-25543eb50cd1/image.png" /></p>
<ul>
<li>두 번째 필드의 종류</li>
<li>언더바(<code>_</code>)가 붙어있는건 자동으로 로딩된 파일</li>
</ul>
<table>
<thead>
<tr>
<th>심볼 타입 명</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>주소가 절대적이어서 변경되지 않는 심볼</td>
</tr>
<tr>
<td>B</td>
<td>심볼이 BSS 섹션에 존재(un-initialized global varible 등)</td>
</tr>
<tr>
<td>C</td>
<td>공통 심볼(un-initialized data)</td>
</tr>
<tr>
<td>D</td>
<td>심볼이 data 섹션에 위치(initialized global variable 등)</td>
</tr>
<tr>
<td>G</td>
<td>작은 공간의 전역 객체, data 섹션에 위치(initialized data 등)</td>
</tr>
<tr>
<td>I</td>
<td>심볼이 다른 심볼의 indirect</td>
</tr>
<tr>
<td>N</td>
<td>디버그 심볼</td>
</tr>
<tr>
<td>R</td>
<td>Read-only 섹션에 존재</td>
</tr>
<tr>
<td>S</td>
<td>작은 객체를 위한 BSS 섹션의 심볼</td>
</tr>
<tr>
<td>T</td>
<td>text 섹션에 있는 심볼(code)</td>
</tr>
<tr>
<td>U</td>
<td>정의되지 않은 심볼</td>
</tr>
<tr>
<td>V</td>
<td>확정적이지 않은 심볼, 링크 시 확정적인 심볼을 만나면 변경</td>
</tr>
<tr>
<td>W</td>
<td>확정적이지 않은 심볼, 링크 시 확정적인 심볼을 만나지 못하면 0으로 설정</td>
</tr>
<tr>
<td>-</td>
<td>stabs 심볼</td>
</tr>
<tr>
<td>?</td>
<td>알수없는 심볼</td>
</tr>
</tbody></table>
<h3 id="32-목적-파일-형식">3.2 목적 파일 형식</h3>
<ul>
<li>목적 파일(Object file) : 플랫폼에서 목적 파일에는 기계 수준의 명령어를 저장하는 목적 파일만의 특정 파일 형식이 존재</li>
</ul>
<p><img alt="" src="https://velog.velcdn.com/images/mommers/post/96977757-0a46-41ed-816b-c0d9f7f109d7/image.png" /></p>
<h3 id="33-재배치-가능한-목적-파일">3.3 재배치 가능한 목적 파일</h3>
<ul>
<li>재배치 가능한(relocatable) 의미? -&gt; 링커가 작업을 수행하는 과정에서 비록된 의미</li>
<li>링커는 재배치 가능한 목적 파일 여러 개를 한데 모아서 더 큰 목적 파일을 형성하는데, 이 파일은 실행가능한 목적 파일 혹은 공유 목적 파일이라고 한다</li>
<li>실행 가능한 목적 파일에서 찾아볼 수 있는 항목은 이 파일을 구성하는 모든 재배치 가능한 목적 파일에서 찾아볼 수 있는 항목의 총합이라는 점</li>
<li>하나의 재배치 가능한 목적 파일에서 나타나는 기계 수준의 명령어는 다른 재배치 가능한 목적파일에서 나온 기계 수준의 명령어 다음에 위치</li>
<li>즉 명령어가 이동할 수 있거나 재배치 가능(relocatable) 하다는 점을 의미</li>
<li>재배치 가능한 목적 파일에서 명령어는 주소를 갖지 않고 링크 단계를 거치고 나서야 주소를 가짐</li>
</ul>
<h3 id="34-실행-가능한-목적-파일">3.4 실행 가능한 목적 파일</h3>
<ul>
<li>실행 가능한 목적 파일이 C 언어의 프로젝트의 최종 결과물중 하나일까?</li>
<li>실행 가능한 목적 파일도 재배치 가능한 목적 파일처럼 기계 수준의 명령어, 초기화된 전역 변수값, 심벌테이블과 같은 항목을 가진다.</li>
<li>하지만 정렬(arrangement)는 다를 수 있다.</li>
<li>Magic 부분만 보고 실행 가능한 파일인지 확인할 수 있다.</li>
</ul>
<p><code>readelf -hSl ./main_shared_app</code></p>
<p><img alt="" src="https://velog.velcdn.com/images/mommers/post/09954e36-a5fe-4c7b-8a0a-8ba483411866/image.png" /></p>
<p><img alt="" src="https://velog.velcdn.com/images/mommers/post/bee464f4-f95b-47c9-bf2c-8f9774f1c9c4/image.png" /></p>
<ul>
<li><p>세그먼트 4개</p>
</li>
<li><ol>
<li>INTERP 세그먼트 : 첫 번째 항목에서 설명?</li>
<li>TEXT 세그먼트 : 기계 수준의 명령어를 갖는 섹션을 모두 포함</li>
<li>DATA 세그먼트 : 전역 변수를 초기화할 때 사용할 모든 값과 다른 초기 구조체 포함</li>
<li>동적 링크 dynamic linking과 관련한 정보를 찾을 수 있는 섹션</li>
</ol>
</li>
<li><p>실행 가능한 목적 파일에서 찾아볼 수 있는 심벌 테이블</p>
</li>
</ul>
<p><code>readelf -s ./main_shared_app</code></p>
<p><img alt="" src="https://velog.velcdn.com/images/mommers/post/c5915478-20b2-4aa0-a766-67ed511ab209/image.png" /></p>
<h3 id="35-정적-라이브러리">3.5 정적 라이브러리</h3>
<ul>
<li><p>C 프로젝트에서 얻을 수 있는 결과물</p>
</li>
<li><p>주소가 확정되지 않은 목적 파일이고, 다른 목적파일들과 링크되어 최종적으로 실행 가능한 목적 파일을 형성</p>
</li>
<li><p>리눅스의 정적 라이브러리는 <code>ELF 파일</code></p>
</li>
<li><p>유닉스의 <code>ar</code> 유틸리티로 파일을 아카이브</p>
</li>
<li><p>링커가 링크 단계에서 정적 라이브러리 사용할 때, 배치 가능한 목적 파일에서 정적 라이브러리 추출하려고 시도하고, 정의되지 않은 심벌을 찾아 해결</p>
</li>
<li><p>규칙</p>
</li>
<li><ol>
<li>이름은 <code>lib</code> 로 시작하고 <code>.a</code> 확장자 -&gt; 리눅스 <code>libmath.a</code></li>
<li>정적 라이브러리에 <code>.lib</code> 확장자 -&gt; 윈도우</li>
</ol>
</li>
<li><p>여러 소스 파일을 그에 해당하는 재배치 가능한 목적 파일로 컴파일하기</p>
<pre><code>gcc -c aa.c -o aa.o
gcc -c aa.c -o aa.o
gcc -c aa.c -o aa.o</code></pre></li>
</ul>
<h2 id="36-동적-라이브러리">3.6 동적 라이브러리</h2>
<ul>
<li><p>재사용 위한 라이브러리 만드는 또 다른 방식</p>
</li>
<li><p>동적 라이브러리는 실행을 위한 프로세스가 로딩될 때 가져와서 로드</p>
</li>
<li><p>정의되지 않은 심벌을 가질 수 있다.</p>
</li>
<li><p>정의되지 않은 심벌은 링크 단계에서 해결되지 않는다.</p>
</li>
<li><p>ELP 실행 파일 및 공유 목적 파일은 각자의 ELP 구조 내에 세그먼트가 있다.</p>
</li>
<li><p>ELP 실행 가능한 목적 파일과 ELF 공유 목적 파일 간에 주요 차이점</p>
<ul>
<li>심벌이 상대적인 절대 주소를 가지며 이 주소를 통해 심벌이 여러 프로세스에 동시에 로드</li>
<li>각 명령어의 주소가 프로세스에서 다른 한편, 두 명령어 사이의 거리는 고정되어 있음을 의미</li>
<li>다시 말하면 주소는 오프셋(offset)에 상대적으로 고정</li>
<li>재배치 가능한 목적 파일이 위치 독립적(position independent)</li>
</ul>
</li>
</ul>
<p><img alt="" src="https://velog.velcdn.com/images/mommers/post/7d832e5a-a5dc-40ab-9bf9-749bc933d2b7/image.png" /></p>
<p>x/8x &lt;주소&gt;</p>
<p><img alt="업로드중.." src="blob:https://velog.io/7365caec-9d95-4000-949a-5eea50cc5dec" /></p>
<p>x/8x 0x&lt;주소&gt;</p>