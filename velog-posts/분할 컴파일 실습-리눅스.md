<p>리눅스 환경에서 <strong>분할 컴파일</strong>, <strong>라이브러리 생성(.a, .so)</strong>, 그리고 <strong>헤더와 라이브러리가 서로 다른 디렉토리에 있을 때의 빌드 과정</strong></p>
<hr />
<h3 id="1-프로젝트-디렉토리-및-파일-준비">1. 프로젝트 디렉토리 및 파일 준비</h3>
<p>먼저, 실제 개발 환경처럼 폴더 구조를 만듭니다.</p>
<ul>
<li><code>include</code>: 헤더 파일(<code>.h</code>) 저장</li>
<li><code>src</code>: 라이브러리 소스 코드(<code>.c</code>) 저장</li>
<li><code>lib</code>: 생성된 라이브러리 파일(<code>.a</code>, <code>.so</code>) 저장</li>
<li><code>app</code>: 메인 프로그램 소스 코드(<code>.c</code>) 저장</li>
</ul>
<h3 id="11-디렉토리-생성">1.1 디렉토리 생성</h3>
<p>터미널에서 다음 명령어를 입력하세요.</p>
<p>Bash</p>
<pre><code class="language-c">mkdir -p my_project/{include,src,lib,app}
cd my_project</code></pre>
<h3 id="12-파일-작성">1.2 파일 작성</h3>
<p>① 헤더 파일 (include/mymath.h)</p>
<p>함수의 원형(Prototype)을 선언합니다.</p>
<p>mymath.h</p>
<pre><code class="language-c">// include/mymath.h
#ifndef MYMATH_H
#define MYMATH_H

int add(int a, int b);
int subtract(int a, int b);

#endif</code></pre>
<p>② 라이브러리 소스 </p>
<p>실제 기능을 구현합니다.</p>
<p>add.c</p>
<pre><code class="language-c">// src/add.c
#include &quot;mymath.h&quot;

int add(int a, int b) {
    return a + b;

  }
</code></pre>
<p>substract.c</p>
<pre><code class="language-c">// src/substract.c
#include &quot;mymath.h&quot;

int subtract(int a, int b) {
    return a - b;
    }</code></pre>
<p>③ 메인 프로그램 (app/main.c)</p>
<p>라이브러리를 사용하는 코드입니다.</p>
<p>main.c</p>
<pre><code class="language-c">// app/main.c
#include &lt;stdio.h&gt;
#include &lt;mymath.h&gt; // &lt;&gt;를 사용합니다 (빌드 시 -I 옵션으로 경로 지정 예정)

int main() {
    int x = 10, y = 5;
    printf(&quot;Add: %d\n&quot;, add(x, y));
    printf(&quot;Subtract: %d\n&quot;, subtract(x, y));
    return 0;
}</code></pre>
<hr />
<h3 id="2-오브젝트-파일-생성-공통-단계">2. 오브젝트 파일 생성 (공통 단계)</h3>
<p>라이브러리를 만들기 전에 소스 코드를 기계어 코드인 오브젝트 파일(.o)로 컴파일해야 합니다.</p>
<p>이때 공유 라이브러리(.so) 생성을 고려하여 -fPIC (Position Independent Code) 옵션을 붙여주는 것이 좋습니다.</p>
<p>Bash</p>
<hr />
<pre><code class="language-c"># -c: 컴파일만 수행 (링크 안 함)
# -fPIC: 위치 독립적 코드 생성 (공유 라이브러리용)
# -I./include: 헤더 파일이 있는 경로 지정

gcc -c -fPIC src/add.c  -I./include -o src/add.o
gcc -c -fPIC src/substract.c -I./include -o src/substract.o</code></pre>
<h3 id="3-정적-라이브러리-a-만들기-및-사용">3. 정적 라이브러리 (.a) 만들기 및 사용</h3>
<p>정적 라이브러리는 프로그램 빌드 시 코드가 실행 파일 안에 <strong>복사</strong>되어 들어갑니다.</p>
<h3 id="31-라이브러리-생성-ar-명령어">3.1 라이브러리 생성 (<code>ar</code> 명령어)</h3>
<p><code>ar</code> (archiver) 명령어를 사용하여 <code>.o</code> 파일을 묶습니다. 라이브러리 이름은 반드시 <code>lib</code>로 시작해야 합니다 (예: <code>libmymath.a</code>).</p>
<p>Bash</p>
<pre><code class="language-c"># r: replace (기존 파일 있으면 덮어쓰기)
# c: create (새로 생성)
# s: index 생성 (링크 속도 향상)

ar rcs lib/libmymath.a src/add.o  src/substract.o</code></pre>
<h3 id="32-정적-라이브러리와-링크하여-빌드하기">3.2 정적 라이브러리와 링크하여 빌드하기</h3>
<p>이제 <code>main.c</code>와 <code>libmymath.a</code>를 합쳐 실행 파일을 만듭니다.</p>
<p>Bash</p>
<h3 id="33-실행">3.3 실행</h3>
<p>정적 라이브러리는 실행 파일에 포함되므로, 라이브러리 파일이 없어져도 실행됩니다.</p>
<pre><code class="language-c">
# -I: 헤더 파일 경로 (include 폴더)
# -L: 라이브러리 파일 경로 (lib 폴더)
# -l: 라이브러리 이름 (libmymath.a에서 앞의 lib와 뒤의 .a를 뗀 이름 'mymath')

gcc -o app/main_static app/main.c -I./include -L./lib -lmymath</code></pre>
<p>Bash</p>
<pre><code class="language-c">./app/main_static</code></pre>
<hr />
<h3 id="4-공유-라이브러리-so-만들기-및-사용">4. 공유 라이브러리 (.so) 만들기 및 사용</h3>
<p>공유 라이브러리는 실행 시점에 메모리에 로드되어 연결됩니다.</p>
<h3 id="41-라이브러리-생성-shared-옵션">4.1 라이브러리 생성 (<code>shared</code> 옵션)</h3>
<p>Bash</p>
<pre><code class="language-c">gcc -shared -o lib/libmymath.so src/add.o src/substract.o</code></pre>
<h3 id="42-공유-라이브러리와-링크하여-빌드하기">4.2 공유 라이브러리와 링크하여 빌드하기</h3>
<p>명령어는 정적 라이브러리 때와 거의 같습니다. 링커는 같은 이름의 <code>.so</code>와 <code>.a</code>가 있으면 <strong>보통 <code>.so</code>를 우선</strong>합니다.</p>
<p>Bash</p>
<pre><code class="language-c">gcc -o app/main_shared app/main.c -I./include -L./lib -lmymath</code></pre>
<h3 id="43-실행-중요-ld_library_path">4.3 실행 (중요: <code>LD_LIBRARY_PATH</code>)</h3>
<p>공유 라이브러리로 빌드한 실행 파일은 실행 시점에 <code>.so</code> 파일을 찾습니다. 기본 시스템 경로(<code>/usr/lib</code> 등)가 아닌 곳에 라이브러리가 있다면, <strong>환경 변수</strong>를 설정해줘야 합니다.</p>
<p>만약 그냥 실행하면 다음과 같은 에러가 납니다:</p>
<blockquote>
<p>error while loading shared libraries: libmymath.so: cannot open shared object file...</p>
</blockquote>
<p><strong>해결 방법:</strong></p>
<p>Bash</p>
<pre><code class="language-c"># 현재 폴더의 lib 디렉토리를 라이브러리 탐색 경로에 추가
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$(pwd)/lib

# 실행
./app/main_shared</code></pre>
<p>쉘에 들어올때마다 export하려면 </p>
<pre><code class="language-c">vi ~/.bashrc

# shift-g =&gt; 맨 밑으로 갑니다.
# a =&gt; insert모드에서 다음을 추가
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/andrew/project/my_project/lib

# esc -&gt; :wq -&gt; enter</code></pre>
<hr />
<h3 id="요약-핵심-옵션-설명">요약: 핵심 옵션 설명</h3>
<table>
<thead>
<tr>
<th><strong>옵션</strong></th>
<th><strong>설명</strong></th>
<th><strong>예시</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>-I&lt;경로&gt;</code></strong></td>
<td><strong>Include Path</strong>. 컴파일러가 헤더 파일(.h)을 찾을 위치 지정</td>
<td><code>-I./include</code></td>
</tr>
<tr>
<td><strong><code>-L&lt;경로&gt;</code></strong></td>
<td><strong>Library Path</strong>. 링커가 라이브러리 파일(.a, .so)을 찾을 위치 지정</td>
<td><code>-L./lib</code></td>
</tr>
<tr>
<td><strong><code>-l&lt;이름&gt;</code></strong></td>
<td><strong>Library Name</strong>. 링크할 라이브러리 이름 지정 (<code>lib</code> 접두사와 확장자 제외)</td>
<td><code>-lmymath</code> (실제 파일명:   <code>-libc</code>, <code>-lmath</code></td>
</tr>
<tr>
<td><code>libmymath.a</code> 또는 <code>libmymath.so</code>)</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong><code>-fPIC</code></strong></td>
<td><strong>Position Independent Code</strong>. 메모리 위치에 상관없이 실행 가능한 코드 생성 (공유 라이브러리 필수)</td>
<td></td>
</tr>
<tr>
<td><strong><code>-shared</code></strong></td>
<td>공유 라이브러리(.so) 생성 옵션</td>
<td></td>
</tr>
</tbody></table>
<h3 id="addc--substract-파일에서-mymathh-를-인클루드-하는-이유는"><code>add.c</code> , <code>substract</code> 파일에서 <code>mymath.h</code> 를 인클루드 하는 이유는?</h3>
<p><code>mymath.c</code> (구현 파일)에서 <code>mymath.h</code> (헤더 파일)를 인클루드하는 것은 C언어 프로그래밍에서 매우 중요한 <strong>표준 규약(Best Practice)</strong>입니다. 그 이유는 크게 두 가지입니다.</p>
<h3 id="1-선언과-정의의-일치-여부-검증-safety--validation">1. 선언과 정의의 일치 여부 검증 (Safety &amp; Validation)</h3>
<p>가장 큰 이유는 <strong>&quot;내가 약속한 대로 만들었는지 컴파일러가 검사하게 하기 위해서&quot;</strong>입니다.</p>
<ul>
<li><em>헤더 파일(<code>mymath.h</code>)*</em>에는 함수의 <strong>**원형(Prototype</strong>)**이 들어있습니다. (일종의 약속)</li>
<li><em>소스 파일(<code>mymath.c</code>)*</em>에는 함수의 <strong><strong>구현(Definition)</strong></strong>이 들어있습니다. (실제 행동)</li>
</ul>
<p>만약 <code>mymath.c</code>가 헤더를 포함하지 않으면, 실수로 함수의 매개변수나 반환 타입을 다르게 작성해도 컴파일러가 이를 알아채지 못하고 <code>.o</code> 파일을 만들어버릴 수 있습니다. 이는 나중에 프로그램을 실행할 때 심각한 오류를 발생시킵니다.</p>
<p><strong>예시 상황 (실수 발생):</strong></p>
<ul>
<li><p><strong>mymath.h (약속):</strong>C</p>
<pre><code class="language-c">  int add(int a, int b); // 인자를 2개 받겠다고 선언</code></pre>
</li>
<li><p><strong>mymath.c (실수):</strong>C</p>
<pre><code class="language-c">  // #include &quot;mymath.h&quot;를 깜빡함!

  // 실수로 인자를 3개 받도록 구현함
  int add(int a, int b, int c) {
      return a + b + c;
  }</code></pre>
</li>
</ul>
<p>위 경우, 헤더를 인클루드하지 않으면 <code>mymath.c</code>를 컴파일할 때(<code>gcc -c ...</code>) 에러가 나지 않을 수 있습니다. 하지만 나중에 이 라이브러리를 사용하는 쪽에서는 인자를 2개만 넣으려 할 것이고, 결국 프로그램은 엉뚱한 동작을 하거나 충돌합니다.</p>
<p><strong>헤더를 인클루드 했다면:</strong>
컴파일러가 <code>mymath.h</code>의 선언과 <code>mymath.c</code>의 구현을 비교하여 <strong>&quot;어? 아까는 인자 2개라고 해놓고 왜 3개짜리를 만드나요?&quot;</strong> 라며 즉시 <strong>컴파일 에러(Conflict type error)</strong>를 띄워줍니다.</p>
<h3 id="2-공통-자료형-및-매크로-사용-dependency">2. 공통 자료형 및 매크로 사용 (Dependency)</h3>
<p>헤더 파일에 단순 함수 선언뿐만 아니라 <strong>구조체(struct), 열거형(enum), 매크로(#define)</strong> 등이 정의되어 있는 경우입니다.</p>
<p>구현 파일(<code>mymath.c</code>)에서 이 타입들을 사용하여 코드를 작성해야 하므로, 당연히 해당 정의가 들어있는 헤더를 인클루드해야 합니다.</p>
<p><strong>예시:</strong></p>
<ul>
<li><p><strong>mymath.h</strong></p>
<pre><code class="language-c">  #define PI 3.14159

  typedef struct {
      int x, y;
  } Point;

  double calculate_area(int radius);</code></pre>
</li>
<li><p><strong>mymath.c</strong></p>
<pre><code class="language-c">  #include &quot;mymath.h&quot; // 이게 없으면 PI와 Point가 뭔지 몰라서 에러 발생

  double calculate_area(int radius) {
      return radius * radius * PI; // PI를 사용함
  }</code></pre>
</li>
</ul>