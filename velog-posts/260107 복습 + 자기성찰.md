<h3 id="c-코딩-시-부족한것">C 코딩 시 부족한것</h3>
<ul>
<li><p>배열이랑 너무 안 친하다는 느낌이 든다.</p>
</li>
<li><p>포인터도 너무 생소하다.</p>
</li>
<li><p>배열 + 포인터는 개념만 알겠고 실제 코드에는 적용이 힘들다.</p>
</li>
<li><p>구조체는 조금씩 알듯 말듯 하나 아직도 잘 모른다.</p>
</li>
<li><p>코드를 직접 짜는 능력</p>
<ul>
<li>코드에서 배열 초기화 정리<ul>
<li>배열 내에 값 차례대로 넣는 알고리즘?</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<h3 id="극복-방안">극복 방안</h3>
<ul>
<li>C언어 교재 1회 정독</li>
<li>배열, 포인터, 구조체 관련 예제 한 번씩 직접 따라서 손코딩 해보기(익숙해지는 용도)</li>
</ul>
<hr />
<h3 id="궁금한-점-정리">궁금한 점 정리</h3>
<ul>
<li>런타임? 컴파일타임?</li>
<li></li>
</ul>
<hr />
<h2 id="복습-내용-정리">복습 내용 정리</h2>
<ul>
<li>함수 앞에 아무것도 없다면 <code>extren</code></li>
<li><code>0x7fffffffd300</code> -&gt; 스택 영역? 다시 알아보기</li>
<li>스택(stack) 구조 -&gt; 스택포인트(sp) 마지막 포인트 위치</li>
</ul>
<p><img alt="" src="https://velog.velcdn.com/images/mommers/post/281f3b6d-d28e-4e44-a455-515bf9e42bca/image.png" /></p>
<h3 id="1-프로그램-로더">1. 프로그램 로더</h3>
<ul>
<li>데이터 영역, 힙 영역 등 초기화</li>
<li>이후 <code>main()</code> 함수 호출</li>
<li>윈도우, 리눅스 교재 다름</li>
</ul>
<h3 id="2-함수-포인터">2. 함수 포인터</h3>
<p><code>int (*fp) (int, int)</code> </p>
<ul>
<li>fp를 변수같이 사용 가능.</li>
</ul>
<p>ex) </p>
<pre><code class="language-c">int (*fp) (int, int)    // 함수 포인터 선언
int sum(int a, int b); 
fp=sum;        // 함수 명을 함수 포인터에 저장</code></pre>
<h3 id="3-void-포인터">3. void 포인터</h3>
<pre><code class="language-c">void* vp;
vp = &amp;a;
printf(&quot;a : %d\n&quot;, *(int*)vp);</code></pre>
<h3 id="4-콜백-함수callback-mechanism">4. 콜백 함수(Callback Mechanism)</h3>
<p>가장 흔한 사용 사례로, 특정 이벤트가 발생하거나 작업이 완료되었을 때 호출될 함수를 인자로 전달한다.</p>
<ul>
<li>사용 이유 : 라이브러리 작성자가 사용자가 정의한 로직을 수행할 수 있도록 &quot;구멍&quot;을 열어두기 위함</li>
<li>대표 사례 : <code>qsort</code> (정렬), <code>pthread_create</code> (스레드 실행), <code>signal</code> (시그널 핸들링)</li>
</ul>
<ol>
<li><code>qsort</code> 활용 예제_1<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
</code></pre>
</li>
</ol>
<p>// 비교 로직을 함수 포인터로 전달
int compare(const void <em>a, const void *b) {
    return (</em>(int<em>)a - *(int</em>)b);
}</p>
<p>int main() {
    int arr[] = {5, 2, 9, 1, 3};
    int n = sizeof(arr) / sizeof(arr[0]);</p>
<pre><code>// qsort의 4번째 인자가 함수 포인터입니다.
qsort(arr, n, sizeof(int), compare); 

for(int i=0; i&lt;n; i++) printf(&quot;%d &quot;, arr[i]);
return 0;</code></pre><p>}</p>
<pre><code>
2. `qsort` 활용 예제_2
```c
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;


typedef struct {
    int id;
    char name[20];
    double score;
}Student;

// 비교 로직을 함수 포인터로 전달

int compare_id(const void *a, const void *b) {
    Student* aa=(Student*)a;
    Student* bb=(Student*)b;

    return(aa-&gt;id-bb-&gt;id);
}

int compare_name(const void *a, const void *b) {

    Student* aa=(Student*)a;
    Student* bb=(Student*)b;

    return(strcmp(aa-&gt;name,bb-&gt;name));

}

int compare_score(const void *a, const void *b) {

    Student* aa=(Student*)a;
    Student* bb=(Student*)b;

    return(bb-&gt;score-aa-&gt;score);
}

int main() {

    Student students[5]={
        {101, &quot;김철수&quot;, 85.5},
        {102, &quot;이영희&quot;, 92.0},
        {103, &quot;박민수&quot;, 78.5},
        {104, &quot;최지우&quot;, 95.0},
        {105, &quot;정수민&quot;, 88.5}
    };

    int n = sizeof(students) / sizeof(students[0]);
    int i;



    printf(&quot;\n&quot;);

    qsort(students,n,sizeof(Student),compare_id);
    printf(&quot;ID \t 이름 \t 점수 \n&quot;);
    for(i=0;i&lt;n;i++){
        printf(&quot;%d\t%s\t %.1lf\n&quot;,students[i].id,students[i].name,students[i].score);
    }

    printf(&quot;\n&quot;);

    qsort(students,n,sizeof(Student),compare_name);
    printf(&quot;ID \t 이름 \t 점수 \n&quot;);
    for(i=0;i&lt;n;i++){
        printf(&quot;%d\t%s\t %.1lf\n&quot;,students[i].id,students[i].name,students[i].score);
    }

    printf(&quot;\n&quot;);

    qsort(students,n,sizeof(Student),compare_score);
    printf(&quot;ID \t 이름 \t 점수 \n&quot;);
    for(i=0;i&lt;n;i++){
        printf(&quot;%d\t%s\t %.1lf\n&quot;,students[i].id,students[i].name,students[i].score);
    }


    return 0;
}</code></pre><p>진짜 이게 뭐라고 하루종일 진땀뺐네..</p>
<p>중요한점!!</p>
<ol>
<li><code>qsort()</code> 인자로 함수 포인터가 오는데, 이때 <code>compare (a,b)</code> 라는 함수가 음수인지, 양수인지, 0인지에 따라 배열이 달라진다.</li>
</ol>
<ul>
<li><code>compare(a,b) &gt; 0</code> 일때 -&gt; a를 뒤로 배치 (순서 b-&gt;a)</li>
<li><code>compare(a,b) &lt; 0</code> 일때 -&gt; a를 앞으로 배치 (순서 a-&gt;b)</li>
<li><code>compare(a,b) == 0</code> 일때 -&gt; 상관 없음</li>
</ul>
<ol start="2">
<li><code>qsort()</code> 함수 원형<pre><code class="language-c">void qsort{
 void *base,
 size_t nmemb,
 size_t size,
 int (*compar)(const void*, const void*)
}</code></pre>
</li>
</ol>
<p>함수 포인터의 인자로 <code>const</code> 가 온다.</p>
<p>++ 나중에 <code>const</code> 정리</p>
<h3 id="5-구조체를-이용한-객체지향oop-흉내내기polymorphism">5. 구조체를 이용한 객체지향(OOP) 흉내내기(Polymorphism)</h3>
<p>C언어에는 클래스가 없지만, 구조체 안에 함수 포인터를 넣어 메서드(Method)처럼 사용할 수 있다. 이를 통해 다형성(Polymorphism)을 구현한다.</p>
<ul>
<li>리눅스 커널 사례 : 리눅스 커널의 <strong>VFS(가상 파일 시스템)</strong>이 이 방식을 완벽하게 보여준다.
<code>file_operations</code> 구조체는 <code>read</code> , <code>write</code> , <code>open</code> 등의 함수 포인터를 가지고 있으며, 디바이스 드라이버마다 실제 동작 함수를 다르게 연결한다.</li>
</ul>
<p>예시 코드 <code>like_oop.c</code></p>
<pre><code class="language-c">typedef struct {
    const char *name;
    void (*speak)(void); // 함수 포인터: 동작 정의
} Animal;

void dog_speak() { printf(&quot;멍멍\n&quot;); }
void cat_speak() { printf(&quot;야옹\n&quot;); }

int main() {
    // 같은 구조체지만 다른 동작을 연결
    Animal dog = {&quot;강아지&quot;, dog_speak};
    Animal cat = {&quot;고양이&quot;, cat_speak};

    dog.speak(); // 멍멍
    cat.speak(); // 야옹
    return 0;
}</code></pre>