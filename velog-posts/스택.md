<h2 id="스택stack이란-">스택(stack)이란 ?</h2>
<ul>
<li>쌓아놓은 더미</li>
<li>후입선출(LIFO)<ul>
<li>가장 최근에 들어온 데이터가 먼저 나감</li>
</ul>
</li>
</ul>
<p><img alt="" src="https://velog.velcdn.com/images/mommers/post/b55f33d9-eab7-4d20-adc0-e5b648ff7790/image.png" /></p>
<h2 id="스택-추상-데이터타입adt">스택 추상 데이터타입(ADT)</h2>
<ul>
<li><p>객체: 0개 이상의 원소를 가지는 유한 선형 리스트</p>
</li>
<li><p>연산:  </p>
<ul>
<li><p>create(size) ::= 최대 크기가 size인 공백 스택을 생성한다.</p>
</li>
<li><p>is_full(s) ::= </p>
<ul>
<li>if(스택의 원소수 == size) return TRUE;</li>
<li>else return FALSE;</li>
</ul>
</li>
<li><p>is_empty(s) ::= </p>
<ul>
<li>if(스택의 원소수 == 0) return TRUE;<ul>
<li>else return FALSE;</li>
</ul>
</li>
</ul>
</li>
<li><p>push(s, item) ::= </p>
<ul>
<li>if( is_full(s) ) return ERROR_STACKFULL;</li>
<li>else 스택의 맨 위에 item을 추가한다.</li>
</ul>
</li>
<li><p>pop(s) ::= </p>
<ul>
<li>if( is_empty(s) ) return ERROR_STACKEMPTY;</li>
<li>else 스택의 맨 위의 원소를 제거해서 반환한다.</li>
</ul>
</li>
<li><p>peek(s) ::= </p>
<ul>
<li>if( is_empty(s) ) return ERROR_STACKEMPTY;</li>
<li>else 스택의 맨 위의 원소를 제거하지 않고 반환한다. </li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="스택의-연산">스택의 연산</h2>
<ul>
<li>push(): 스택에 데이터를 추가</li>
<li>pop(): 스택에서 데이터를 삭제</li>
</ul>
<img alt="image" height="270" src="https://github.com/user-attachments/assets/965e9dbd-e32f-4e6a-9428-bca534c08603" width="876" />

<ul>
<li>is_empty(s): 스택이 공백상태인지 검사</li>
<li>is_full(s): 스택이 포화상태인지 검사</li>
<li>create(): 스택을 생성 </li>
<li>peek(s): 요소를 스택에서 삭제하지 않고 보기만 하는 연산<ul>
<li>(참고)pop 연산은 요소를 스택에서 완전히 삭제하면서 가져온다. </li>
</ul>
</li>
</ul>
<h2 id="배열을-이용한-스택의-구현">배열을 이용한 스택의 구현</h2>
<ul>
<li>1차원 배열 stack[ ]</li>
<li>스택에서 가장 최근에 입력되었던 자료를 가리키는 top 변수</li>
<li>가장 먼저 들어온 요소는 stack[0]에, 가장 최근에 들어온 요소는 stack[top]에 저장</li>
<li>스택이 공백상태이면 top은 -1</li>
</ul>
<h2 id="is_emptys-is_fulls-연산의-구현">is_empty(S), is_full(S) 연산의 구현</h2>
<img alt="image" height="525" src="https://github.com/user-attachments/assets/a1b35e89-f97e-4e71-b098-0456835684e1" width="869" />

<h2 id="push-연산">push 연산</h2>
<p>push(S, x): 
if is_full(S) 
     then error &quot;overflow&quot; 
     else top←top+1 
          stack[top]←x</p>
<img alt="image" height="298" src="https://github.com/user-attachments/assets/a2ef262b-dd3f-4f49-9b7a-e3ce06d740d9" width="500" />

<h2 id="pop-연산">pop 연산</h2>
<p>pop(S, x): 
if is_empty(S) 
     then error &quot;underflow&quot; 
     else e←stack[top] 
          top←top-1 
          return e</p>
<img alt="image" height="309" src="https://github.com/user-attachments/assets/07e96fe9-d729-4d53-b25b-e9bd68870ca8" width="560" />

<h2 id="전역-변수로-구현하는-방법">전역 변수로 구현하는 방법</h2>
<h3 id="p">p</h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define MAX_STACK_SIZE 100    // 스택의 최대 크기
typedef int element;        // 데이터의 자료형
element  stack[MAX_STACK_SIZE]; // 1차원 배열
int  top = -1;

// 공백 상태 검출 함수
int is_empty()
{
    return (top == -1);
}
// 포화 상태 검출 함수
int is_full()
{
    return (top == (MAX_STACK_SIZE - 1));
}
// 삽입 함수
void push(element item)
{
    if (is_full()) {
        fprintf(stderr, &quot;스택 포화 에러\n&quot;);
        return;
    }
    else stack[++top] = item;
}
// 삭제 함수
element pop()
{
    if (is_empty()) {
        fprintf(stderr, &quot;스택 공백 에러\n&quot;);
        exit(1);
    }
    else return stack[top--];
}
int main(void)
{
    push(1);
    push(2);
    push(3);
    printf(&quot;%d\n&quot;, pop());
    printf(&quot;%d\n&quot;, pop());
    printf(&quot;%d\n&quot;, pop());
    return 0;
}</code></pre>
<img alt="image" height="204" src="https://github.com/user-attachments/assets/f39f2d2f-5f5d-4148-b8de-36e080b8c85f" width="1102" />

<hr />
<h2 id="구조체-배열-사용하기">구조체 배열 사용하기</h2>
<pre><code class="language-c">#define MAX_STACK_SIZE 100
#include&lt;stdio.h&gt;

typedef int element;
typedef struct {
    element data[MAX_STACK_SIZE];
    int top;
} StackType;

// 스택 초기화 함수
void init_stack(StackType* s)
{
    s-&gt;top = -1;
}

// 공백 상태 검출 함수
int is_empty(StackType* s)
{
    return (s-&gt;top == -1);
}
// 포화 상태 검출 함수
int is_full(StackType* s)
{
    return (s-&gt;top == (MAX_STACK_SIZE - 1));
}
// 삽입함수
void push(StackType* s, element item)
{
    if (is_full(s)) {
        fprintf(stderr, &quot;스택 포화 에러\n&quot;);
        return;
    }
    else s-&gt;data[++(s-&gt;top)] = item;
}
// 삭제함수
element pop(StackType* s)
{
    if (is_empty(s)) {
        fprintf(stderr, &quot;스택 공백 에러\n&quot;);
        exit(1);
    }
    else return s-&gt;data[(s-&gt;top)--];
}
int main(void)
{
    StackType s;

    init_stack(&amp;s);
    push(&amp;s, 1);
    push(&amp;s, 2);
    push(&amp;s, 3);
    printf(&quot;%d\n&quot;, pop(&amp;s));
    printf(&quot;%d\n&quot;, pop(&amp;s));
    printf(&quot;%d\n&quot;, pop(&amp;s));
}
</code></pre>
<img alt="image" height="204" src="https://github.com/user-attachments/assets/7d711e30-88c4-43b5-89cd-df7faa4f922e" width="1105" />

<hr />
<h2 id="동적-배열-스택">동적 배열 스택</h2>
<pre><code class="language-c">#define MAX_STACK_SIZE 100
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

typedef int element;
typedef struct {
    element data[MAX_STACK_SIZE];
    int top;
} StackType;


// 스택 초기화 함수
void init_stack(StackType* s)
{
    s-&gt;top = -1;
}

// 공백 상태 검출 함수
int is_empty(StackType* s)
{
    return (s-&gt;top == -1);
}
// 포화 상태 검출 함수
int is_full(StackType* s)
{
    return (s-&gt;top == (MAX_STACK_SIZE - 1));
}
// 삽입함수
void push(StackType* s, element item)
{
    if (is_full(s)) {
        fprintf(stderr, &quot;스택 포화 에러\n&quot;);
        return;
    }
    else s-&gt;data[++(s-&gt;top)] = item;
}

// 삭제함수
element pop(StackType* s)
{
    if (is_empty(s)) {
        fprintf(stderr, &quot;스택 공백 에러\n&quot;);
        exit(1);
    }
    else return s-&gt;data[(s-&gt;top)--];
}
int main(void)
{
    StackType s;
    init_stack(&amp;s);
    push(&amp;s, 1);
    push(&amp;s, 2);
    push(&amp;s, 3);
    printf(&quot;%d\n&quot;, pop(&amp;s));
    printf(&quot;%d\n&quot;, pop(&amp;s));
    printf(&quot;%d\n&quot;, pop(&amp;s));
    return 0;
}

</code></pre>
<img alt="image" height="195" src="https://github.com/user-attachments/assets/26ef4f2c-d239-463c-b0c8-2fa66518f62a" width="1106" />

<hr />
<h1 id="수식의-계산">수식의 계산</h1>
<ul>
<li><p>수식 표기 방법 : 전위(prefix), 중위(infix), 후위(postfix)</p>
<img alt="image" height="187" src="https://github.com/user-attachments/assets/dd5b1394-a449-4f5a-9e55-444e7914419c" width="975" />
</li>
<li><p>컴퓨터에서의 수식 계산 순서</p>
<ul>
<li><p>중위 표기식 -&gt; 후위 표기식 -&gt; 계산</p>
</li>
<li><p>2+3<em>4 -&gt; 234</em>+ -&gt; 14</p>
</li>
<li><p>모두 스택을 사용</p>
</li>
<li><p>먼저 후위표기식의 계산법을 알아보자</p>
<pre><code> - 수식을 왼쪽에서 오른쪽으로 스캔하여 피연산자이면 스택에 저장하고 연산자이면 필요한 수만큼의 피연산자를 스택에서 꺼내 연산을 실행하고 연산의 결과를 다시 스택에 저장

- 예) 82/3-32*+</code></pre></li>
</ul>
</li>
</ul>
<img alt="image" height="312" src="https://github.com/user-attachments/assets/e33f47ed-6ff4-4b9f-afcf-5b525d1fec29" width="340" />

<img alt="image" height="690" src="https://github.com/user-attachments/assets/6a6fdd64-eb9f-49d0-8eab-9966daca9082" width="718" />

<h2 id="후위표기식-계산-알고리즘">후위표기식 계산 알고리즘</h2>
<img alt="image" height="351" src="https://github.com/user-attachments/assets/abce7851-be04-44d7-b81c-811ea5b5704b" width="802" />

<p>&lt;후위 표기식 계산&gt;</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define MAX_STACK_SIZE 100

typedef char element;    
typedef struct {
    element* data;
    int capacity;
    int top;
} StackType;

int eval(char exp[])
{
    int op1, op2, value, i = 0;
    int len = strlen(exp);
    char ch;
    StackType s;
    init_stack(&amp;s);
    for (i = 0; i &lt; len; i++) {
        ch = exp[i];
        if (ch != '+' &amp;&amp; ch != '-' &amp;&amp; ch != '*' &amp;&amp; ch != '/') {
            value = ch - '0';    // 입력이 피연산자이면
            push(&amp;s, value);
        }
        else {    //연산자이면 피연산자를 스택에서 제거
            op2 = pop(&amp;s);
            op1 = pop(&amp;s);
            switch (ch) { //연산을 수행하고 스택에 저장 
            case '+': push(&amp;s, op1 + op2); break;
            case '-': push(&amp;s, op1 - op2); break;
            case '*': push(&amp;s, op1 * op2); break;
            case '/': push(&amp;s, op1 / op2); break;
            }
        }
    }
    return pop(&amp;s);
}
int main(void)
{
    int result;
    printf(&quot;후위표기식은 82/3-32*+\n&quot;);
    result = eval(&quot;82/3-32*+&quot;);
    printf(&quot;결과값은 %d\n&quot;, result);
    return 0;
}</code></pre>
<img alt="image" height="188" src="https://github.com/user-attachments/assets/eeb36280-f6b5-4452-98c9-987248781212" width="1111" />