<h2 id="순환recursion이란">순환(recursion)이란?</h2>
<ul>
<li>알고리즘이나 함수가 수행 도중에 자기 자신을 다시 호출하여 문제를 해결하는 기법</li>
<li>정의 자체가 순환적으로 되어 있는 경우에 적합</li>
</ul>
<p><img alt="" src="https://velog.velcdn.com/images/mommers/post/2c0a9312-457c-499b-baa4-827ef736cd84/image.png" /></p>
<h3 id="팩토리얼-1">팩토리얼 1</h3>
<p>int factorial(int n)
{
    if( n&lt;= 1 ) return(1);
    else return (n * factorial_n_1(n-1) );
}</p>
<h3 id="팩토리얼-2">팩토리얼 2</h3>
<p>int factorial(int n)
{
    if( n &lt;= 1 ) return(1);
    else return (n * factorial(n-1) );
}</p>
<ul>
<li>순환을 멈추는 부분이 있어야 한다.</li>
<li>대부분의 순환은 &quot;반복&quot; 으로 바꿔 작성 가능하다.</li>
</ul>
<img alt="image" height="411" src="https://github.com/user-attachments/assets/d42b729c-db6a-4299-98d8-514cdd970e15" width="858" />

<ul>
<li>숫자 x의 n제곱 값을 구하는 문제: x^n</li>
</ul>
<p>double slow_power(double x, int n)
{
    int i;
    double result = 1.0;
    for(i=0; i&lt;n; i++)
        result = result * x;
    return(result);
}</p>
<ul>
<li>순환적인 알고리즘
power(x, n)</li>
</ul>
<p>if n==0 
    then return 1;
else if n이 짝수 
    then return power(x2, n/2);
else if n이 홀수<br />    then return x*power(x2, (n-1)/2);</p>
<p>double power(double x, int n)
{
    if( n==0 ) return 1;
    else if ( (n%2)==0 ) 
        return power(x<em>x, n/2);
    else return x</em>power(x*x, (n-1)/2);
}</p>
<h3 id="거듭제곱-값-프로그래밍-분석">거듭제곱 값 프로그래밍 분석</h3>
<ul>
<li><p>시간 복잡도</p>
<ul>
<li><p>반복적인 방법과 순환적인 방법의 비교</p>
<img alt="image" height="109" src="https://github.com/user-attachments/assets/972b4266-bb9a-4245-807d-aaa5daafbedd" width="704" />

</li>
</ul>
</li>
</ul>
<h3 id="피보나치-수열-계산-1">피보나치 수열 계산 1)</h3>
<ul>
<li>순환 호출시 비효율적인 예시이다.
int fib(int n)
{
  if( n==0 ) return 0;
  if( n==1 ) return 1;
  return (fib(n-1) + fib(n-2));
}</li>
<li>순환 호출을 사용했을 경우의 비효율성 <ul>
<li>같은 항이 중복해서 계산됨 </li>
<li>예를 들어 fib(6)을 호출하게 되면 fib(3)이 4번이나 중복되어서 계산됨</li>
<li>이러한 현상은 n이 커지면 더 심해짐</li>
</ul>
</li>
</ul>
<h3 id="피보나치-수열의-반복-구현">피보나치 수열의 반복 구현</h3>
<p>int fib_iter(int n)
{
    if (n == 0) return 0;
    if (n == 1) return 1;</p>
<pre><code>int pp = 0;    
int p = 1;
int result = 0;

for (int i = 2; i &lt;= n; i++) {
    result = p + pp;
    pp = p;
    p = result;
}
return result;</code></pre><p>} </p>
<h3 id="하노이-탑-문제">하노이 탑 문제</h3>
<ul>
<li><p>문제는 막대 A에 쌓여있는 원판 n개를 막대 C로 옮기는 것이다. </p>
<ul>
<li>한 번에 하나의 원판만 이동할 수 있다 </li>
<li>맨 위에 있는 원판만 이동할 수 있다 </li>
<li>크기가 작은 원판 위에 큰 원판이 쌓일 수 없다. </li>
<li>중간의 막대를 임시적으로 이용할 수 있으나 앞의 조건들을 지켜야 한다.</li>
</ul>
<img alt="image" height="190" src="https://github.com/user-attachments/assets/a322aba8-e03a-48af-a09f-f69e046249c6" width="521" />



</li>
</ul>